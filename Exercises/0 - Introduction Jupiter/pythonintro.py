# -*- coding: utf-8 -*-
"""PythonIntro.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KHAWXgMbBxxW98t4PV_g1hn5VNshBcW8

# Installing the latest python 3 version and its necessary packages

We strongly recommend installing Miniconda. There are installers for the 3 main Operating Systems (Linux, Windows & MacOS) https://docs.conda.io/en/latest/miniconda.html. 

To use the full 'power' of `python` you'll need a package manager to download and install all the necessary . The default one is `pip`, but in our current configuration we recommend you use `conda` (for the interested people among you, [here](https://www.anaconda.com/using-pip-in-a-conda-environment/) is a link to a blog post explaining why mixing both is bad idea).

Once you've installed miniconda, open a terminal and install the following packages:

`sklearn`, `numpy`, `pandas`, `matplotlib` by doing:

`conda install <packages>`

# What is a Jupyter Notebook?

Python can be executed via the command line (by calling `python <program>.py` or inside a so called [`notebook`](https://jupyter.org/install). 

A notebook is a file composed of `cells` which can be executed seperately (`ctrl`+`enter` or `shift`+`enter` to also go to the next one) but that **share** a same memory system. This means that variables initialized in a certain cell can be accessed from any other cell as long as the former is executed *before* the latter. Try executing the 2 following cells
"""

a = 5

print(a)

"""A `cell` can thus be used to write and execute code or to write text. The default text format is [Markdown](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet). Text mode also supports $\LaTeX$ math environments which can be defined with the `$`-sign: $\forall b \in \mathcal{B}: b \ge \frac{5}{2}$

# The Fundamentals

The python language syntax decided to do away with curly brackets and decided on seperating code-blocks by line indentations. The colon (`:`) indicates the start of such a new indentation
"""

a = 5
if a == 5:
  print("a is equal to 5")
else:
  print("Sadly a is not a beautiful 5 anymore :'(")

"""Python is strongly **dynamically** typed language. This means that a variable's `type` is only checked at runtime (= when executing the code), the same was already true for `R` and `Matlab`. If there is a term you don't understand, you'll find a handy glossary [here](https://docs.python.org/3.1/glossary.html).

The base types are the following:
* `int`: integer values
* `float`: floating point values
* `str`: strings of characters
* `bool`: `True` or `False`


But also more complex ones:
* `list`: A list of items
* `tuple`: An immutable list of items
* `dict`: A `key`-`value` store, the keys can be of various types as long as they are hashable
* `set`: A hashset of unique values

The number of elements in thos data structures can be obtained by calling the `len` function. Note that, contrary to some other languages (i.e. `Matlab`), **the indexation starts at zero**.
"""

# (Text preceded by a '#' is ignored)
# Base types
a = 5
print(f"Example of integer division: {a//2} vs floating point division: {a/2}")
b = 3.5
c = "Hey I'm a suite of characters"

always_true = True or False
always_false = True and False
always_false = not True

# Advanced types
li = [1,2,3]
li.append(5)
print(f"I'm a list of length {len(li)}")

tu = (7,9,8)
t1, t2, t3 = tu
print(f"Does t2 contain the same values as the second element in the tuple? {t2==tu[1]}")

dico = {
    "hey": 1,
    56897: 6
}
print(f"At key 'hey' in dico the value is: {dico['hey']}")

se = set([1,1,1,1,2,3,4,5,5,5,6])
print(f"This set only has {len(se)} elements")

"""(By now you'll have noted that we used a strange `string` format called `f-string` to print the values behind the variables, [here](https://realpython.com/python-f-strings/) you can find a more detailed explanation on the inner workings.)

There is also a whole slew of even more versatile data structures in the `collections` [package](https://docs.python.org/3/library/collections.html). A handy one is the `defaultdict` which gives a default `value` to a previously unseen `key`.
"""

# Importing a specific function or class from another package follows this syntax
# from <package> import <function>
from collections import defaultdict
a = defaultdict(int)
print(f"The default value is {a['whatever']}")

"""# Iterators

There are a few easy ways to iterate over data structures in python, the most important ones are listed below, but this is far from an exhaustive list.
"""

# The basic iterator or for loop
print("Range 1")
for i in range(3):
  print(i, end=', ')

print("\n\nRange 2")
for i in range(4,9,2):
  print(i, end=', ')

# Iterating over a list
print("Iterating over list")
for elem in li:
  print(elem, end=', ')

print("\n\nIterating over list with indices")
for index, elem in enumerate(li):
  print(f"At index {index}: {elem}")

print("\nIterating over 2 list of the same size simultaneously")
li2 = li.copy() # duplicates a list
li2[1] = 150
for elem, elem2 in zip(li, li2):
  print(elem, elem2)

# Iterating over a dictionary
print("Simple dict iteration")
for key in dico: # An equivalent formulation would be: for key in dico.keys()
  print(f"Value {dico[key]} at key {key}")

print("\nIterating over values only")
for value in dico.values():
  print(value, end=', ')

print("\n\nIterating over both at once")
for key, value in dico.items():
  print(f"Value {value} at key {key}")

"""# Functions and classes

Python supports both functional programming and object oriented programming with inheritance (like in Java).

As was already stated, python is dynamically typed, so during function definition you don't need to specify an argument's type. You can however give it a default value.
"""

# Example of function definition
def line(x, alpha=1, c=0):
  """ Returns the y-value of the line with coefficients:
      - alpha (steepness) 
      - c (offset)
      at point x 
  """
  return alpha*x + c

# OK
print(line(5))
print(line(5, 2, 1))
print(line(5, c=1, alpha=2)) # If you name the arguments, order is not important
print(line(x=5, c=1, alpha=2))

# Not ideal
print(line(c=1, alpha=2, x=5)) # But moving the arguments without defaults like 
                               # this, is not really good practice

# Example of a class definition
class Line():
  def __init__(self, alpha=1, c=0): # This is the object's constructor
    """ Creates the Line objectwith coefficients:
      - alpha (steepness) 
      - c (offset)
    """
    self.alpha = alpha
    self.c = c

  def get_y(self, x):
    """ Returns the value of the line at point x
    """
    return self.alpha*x + self.c

simple_line = Line(alpha=2, c=1)
print(simple_line.get_y(5))

"""# Pitfalls

Python is not without its flaws, and one you should really look out for is the scope of variables. For example in most languages the following example would throw an error, but not here. This is due to python not really limiting the scope of certain variables inside a function
"""

for i in range(6):
    pass

print("i after for loop = ", i) # i still exists!!

def test():
  print("i in test = ", i) # i is still acessible here too!!
  j = 5
test()
try:
  print(j) # But j is not accessible here
except:
  print("j is not declared")

"""# Final words
Do not hesitate to read the excellent official [documentation](https://docs.python.org/3/) or the Q&A's on StackOverflow to find new ways to write better code, but never forget to cite your sources and have fun!
"""